---
title: Migrieren von ASP.net Core 2,2 zu 3,0
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.net Core 2,2-Projekt zu ASP.net Core 3,0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 5f6b0b8d56649dc5fd194ee43d93139f80ce9106
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060429"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.net Core 2,2 zu 3,0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.net Core 2,2-Projekt auf ASP.net Core 3,0 aktualisiert wird. Es ist möglicherweise hilfreich, ein neues ASP.net Core 3,0-Projekt zu erstellen:

* Vergleichen Sie mit dem ASP.net Core 2,2-Code.
* Kopieren Sie die relevanten Änderungen in das Projekt ASP.net Core 3,0.

## <a name="prerequisites"></a>Voraussetzungen

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualisieren der .NET Core SDK-Version in „global.json“

Wenn Ihre Lösung auf eine [global.js](/dotnet/core/tools/global-json) Datei basiert, die auf eine bestimmte .net Core SDK Version ausgerichtet ist, aktualisieren Sie Ihre- `version` Eigenschaft auf die Version 3,0, die auf Ihrem Computer installiert ist:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Ziel Frameworks

ASP.net Core 3,0 und höher wird nur unter .net Core ausgeführt. Legen Sie für den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) Folgendes fest `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Veraltete Paket Verweise entfernen

Eine große Anzahl von nuget-Paketen wird nicht für ASP.net Core 3,0 erstellt. Solche Paket Verweise sollten aus der Projektdatei entfernt werden. Sehen Sie sich die folgende Projektdatei für eine ASP.net Core 2,2-Web-App an:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Die aktualisierte Projektdatei für ASP.net Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Die aktualisierte ASP.net Core 3,0-Projektdatei:

* In `<PropertyGroup>`:
  * Aktualisiert den TFM auf `netcoreapp3.0`
  * Entfernt das- `<AspNetCoreHostingModel>` Element. Weitere Informationen finden Sie unter [in-Process-Hostingmodell](#in-process-hosting-model) in diesem Dokument.

* In `<ItemGroup>`:
  * `Microsoft.AspNetCore.App` wurde entfernt. Weitere Informationen finden Sie in diesem Dokument in der [frameworkreferenz](#framework-reference) .
  * `Microsoft.AspNetCore.Razor.Design` wurde entfernt und in der folgenden Liste von Paketen, die nicht mehr erstellt werden.

Um die vollständige Liste der Pakete anzuzeigen, die nicht mehr erstellt werden, wählen Sie die folgende Erweiterungs Liste aus:

<details>
    <summary>Klicken Sie, um die Liste der Pakete zu erweitern, die nicht mehr erstellt werden</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. aspnetcore. Authentication. Cookie Hymnen</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. aspnetcore. Cookie Policy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. aspnetcore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft. aspnetcore. MVC. Razor . Viewcompilation</li>
        <li>Microsoft. aspnetcore. MVC. Razor Seiten</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. aspnetcore.Razor</li>
        <li>Microsoft. aspnetcore. Razor . Runtime</li>
        <li>Microsoft. aspnetcore. Razor . Ausge</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. aspnetcore.SignalR</li>
        <li>Microsoft. aspnetcore. SignalR . Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Wichtige Änderungen überprüfen

[Wichtige Änderungen überprüfen](#break)

### <a name="framework-reference"></a>Frameworkverweis

Features von ASP.net Core, die über eines der oben aufgeführten Pakete verfügbar waren, sind als Teil des frei `Microsoft.AspNetCore.App` gegebenen Frameworks verfügbar. Das *freigegebene Framework* ist der Satz von Assemblys ( *DLL* -Dateien), die auf dem Computer installiert werden und eine Laufzeitkomponente sowie ein Zielpaket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf das `Microsoft.NET.Sdk.Web` SDK abzielen, verweisen implizit auf das `Microsoft.AspNetCore.App`-Framework.

  Für diese Projekte sind keine weiteren Verweise erforderlich:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekte, die das Ziel `Microsoft.NET.Sdk` oder das `Microsoft.NET.Sdk.Razor` SDK sind, sollten eine explizite zu folgenden hinzufügen `FrameworkReference` `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mithilfe von Docker

Framework-abhängige Builds von Konsolen-apps, die ein Paket verwenden, das vom ASP.net Core [Shared Framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` ist das freigegebene Framework, das die ASP.net Core Runtime enthält und nur auf dem docker-Image [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist. Das 3,0 SDK reduziert die Größe von Framework-abhängigen Builds mit ASP.net Core, indem doppelte Kopien von Bibliotheken, die im freigegebenen Framework verfügbar sind, nicht eingeschlossen werden. Dies ist eine potenzielle Einsparung von bis zu 18 MB, aber es ist erforderlich, dass die ASP.net Core-Laufzeit zum Ausführen der app vorhanden bzw. installiert ist.

Um zu ermitteln, ob die APP eine Abhängigkeit (entweder direkt oder indirekt) auf dem ASP.net Core freigegebenen Framework hat, überprüfen Sie die *runtimeconfig.jsauf* die Datei, die während eines Builds/veröffentlichtes Ihrer APP generiert wurde. Die folgende JSON-Datei zeigt eine Abhängigkeit vom ASP.net Core Shared Framework:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre APP docker verwendet, verwenden Sie ein Basis Image, das ASP.net Core 3,0 enthält. Beispiel: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Paket Verweise für entfernte Assemblys hinzufügen

ASP.net Core 3,0 entfernt einige Assemblys, die zuvor Teil des `Microsoft.AspNetCore.App` Paket Verweises waren. Um zu visualisieren, welche Assemblys entfernt wurden, vergleichen Sie die beiden freigegebenen frameworkordner Beispielsweise ein Vergleich der Versionen 2.2.7 und 3.0.0:

![Vergleich von Shared Framework](22-to-30/_static/assembly-diff.png)

Um die von den entfernten Assemblys bereitgestellten Funktionen weiterhin zu verwenden, verweisen Sie auf die 3,0-Versionen der entsprechenden Pakete:

* Bei einer Vorlagen generierten Web-App mit **einzelnen Benutzerkonten** müssen die folgenden Pakete hinzugefügt werden:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Weitere Informationen zum Verweisen auf das Datenbankanbieter spezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index).

* Benutzeroberfläche von Identity

  Unterstützung für die [ Identity Benutzeroberfläche](xref:security/authentication/identity) kann durch Verweisen auf [Microsoft. aspnetcore. hinzugefügt Identity werden. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) -Paket.

* Spa-Dienste

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. aspnetcore. Spaservices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Authentifizierung: die Unterstützung für Authentifizierungs Abläufe von Drittanbietern ist als nuget-Pakete verfügbar:

  * Facebook OAuth ([Microsoft. aspnetcore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. aspnetcore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft-Konto Authentifizierung ([Microsoft. aspnetcore. Authentication. microsoftaccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft. aspnetcore. Authentication. openidconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect-bearertoken ([Microsoft. aspnetcore. Authentication. jwtbearertoken](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. aspnetcore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Wsfederation-Authentifizierung ([Microsoft. aspnetcore. Authentication. wsfederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Unterstützung von Formatierung und Inhaltsaushandlung für `System.Net.HttpClient` : das nuget-Paket [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) bietet nützliche Erweiterbarkeit für `System.Net.HttpClient` mit APIs wie `ReadAsAsync` und `PostJsonAsync` .

* Razor Lauf Zeit Kompilierung: die Unterstützung für die Lauf Zeit Kompilierung von Razor Sichten und Seiten ist nun Bestandteil von [Microsoft. aspnetcore. MVC. Razor Runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC- `Newtonsoft.Json` Unterstützung (JSON.net): die Unterstützung für die Verwendung von MVC mit `Newtonsoft.Json` ist nun Bestandteil von [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Start Änderungen

Die folgende Abbildung zeigt die gelöschten und geänderten Zeilen in einer ASP.net Core-Web-App mit 2,2- Razor Seiten:

![die gelöschten und geänderten Zeilen in einem ASP.net Core 2,2::: NO-LOC (Razor)::: Web-App](22-to-30/_static/startup2.2.png)

In der vorangehenden Abbildung ist gelöschter Code rot dargestellt. Der gelöschte Code zeigt keinen cookie options Code an, der vor dem Vergleichen der Dateien gelöscht wurde.

In der folgenden Abbildung werden die hinzugefügten und geänderten Zeilen in einer ASP.net Core-Web-App mit 3,0- Razor Seiten angezeigt

![die hinzugefügten und geänderten Zeilen in einer ASP.net Core 3,0::: NO-LOC (Razor)::: Web-App](22-to-30/_static/startup3.0.png)

In der vorangehenden Abbildung ist der hinzugefügte Code grün dargestellt. Weitere Informationen zu den folgenden Änderungen:

* `services.AddMvc` Informationen zu finden Sie unter `services.AddRazorPages` [MVC-Dienst Registrierung](#mvc-service-registration) in diesem Dokument.
* `CompatibilityVersion`finden Sie unter <xref:mvc/compatibility-version> .
* `IHostingEnvironment` zu `IWebHostEnvironment` finden Sie [diese GitHub-Ankündigung](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` wurde den Vorlagen hinzugefügt, um anzuzeigen, dass die Middleware für die Bestell Autorisierung hinzugefügt werden muss. Wenn die APP keine Autorisierung verwendet, können Sie den-Befehl problemlos entfernen `app.UseAuthorization` .
* `app.UseEndpoints`finden Sie in diesem Dokument unter [ Razor Seiten](#razor-pages) oder [Migrieren Startup.Configure](#migrate-startupconfigure) .

### <a name="analyzer-support"></a>Analyse Unterstützung

Projekte, die `Microsoft.NET.Sdk.Web` implizit auf Analysen abzielen, die zuvor als Teil des Pakets [Microsoft. aspnetcore. MVC. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Verweise erforderlich, um diese zu aktivieren.

Wenn Ihre APP [API-Analysen](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem Paket [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie die Projektdatei so, dass Sie auf die Analysen verweist, die als Teil des .net Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>Razor Klassenbibliothek

Razor In Klassen Bibliotheks Projekten, die Benutzeroberflächen Komponenten für MVC bereitstellen, muss die- `AddRazorSupportForMvc` Eigenschaft in der Projektdatei festgelegt werden:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

-Projekte werden standardmäßig in ASP.net Core 3,0 oder höher auf das [in-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) eingestellt. Wenn der Wert lautet, können Sie optional die- `<AspNetCoreHostingModel>` Eigenschaft in der Projektdatei entfernen `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguration

Migrieren Sie die Kestrel-Konfiguration zum von bereitgestellten [Webhost](#hostb) -Generator `ConfigureWebHostDefaults` ( *Program.cs* ):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die APP den Host mit manuell erstellt `HostBuilder` , müssen Sie `UseKestrel` auf dem Webhost-Generator in folgenden Befehl ausführen `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungs-Middleware ersetzt Verbindungs Adapter

Verbindungs Adapter ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungs Adapter durch Verbindungs Middleware. Die Verbindungs Middleware ähnelt http-Middleware in der ASP.net Core Pipeline, aber für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungs Protokollierung:

* Wurden von Verbindungs Adaptern zur Verbindungs Middleware verschoben.
* Diese Erweiterungs Methoden funktionieren wie in früheren Versionen von ASP.net Core. 

Weitere Informationen finden Sie [im Abschnitt "tlsfilterconnectionhandler" im Abschnitt "listenoptions. Protokolls" im Kestrel-Artikel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transport Abstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions` als öffentliche Schnittstelle verfügbar gemacht. Als Teil dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` und zugeordnete Typen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> zu den Transport Optionen verschoben.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` wurde aus entfernt <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerk Abstraktionen (dotnet/aspnetcore-#10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementieren Sie die neue Fundament-Listener-Abstraktion und REPLAT Kestrel (dotnet/aspnetcore-#10321).](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Anforderungs Nachspann Header

Für apps, die auf frühere Versionen von ASP.net Core abzielen:

* Kestrel fügt der Auflistung der Anforderungs Header HTTP/1.1-Auflistungs Header hinzu.
* Nach dem Lesen des Anforderungs Texts sind die nach dem Ende des Anforderungs Texts verfügbar.

Dies bewirkt einige Bedenken bezüglich der Mehrdeutigkeit zwischen Headern und nach Spann, sodass die Nachspann in eine neue Sammlung ( `RequestTrailerExtensions` ) in 3,0 verschoben wurden.

HTTP/2-Anforderungs Nachspann:

* Nicht verfügbar in ASP.net Core 2,2.
* Verfügbar in 3,0 als `RequestTrailerExtensions` .

Für den Zugriff auf diese Nachspann sind neue Anforderungs Erweiterungs Methoden vorhanden. Wie bei HTTP/1.1 sind Nachspann verfügbar, nachdem der Anforderungs Text bis zum Ende gelesen wurde.

Für die Version 3,0 sind die folgenden `RequestTrailerExtensions` Methoden verfügbar:

* `GetDeclaredTrailers`: Ruft den Anforderungs `Trailer` Header ab, der auflistet, welche Nachspann nach dem Text erwartet werden.
* `SupportsTrailers`: Gibt an, ob die Anforderung das Empfangen von nach Spann Headern unter
* `CheckTrailersAvailable`: Überprüft, ob die Anforderung Nachspann unterstützt und ob Sie gelesen werden können. Bei dieser Überprüfung wird nicht davon ausgegangen, dass zum Lesen von nach spannenden Möglicherweise gibt es keine zu lesenden Nachspann, auch wenn `true` von dieser Methode zurückgegeben wird.
* `GetTrailer`: Ruft den angeforderten nachfolgenden Header aus der Antwort ab. Überprüfen Sie `SupportsTrailers` vor dem Aufrufen von `GetTrailer` , oder <xref:System.NotSupportedException> kann eintreten, wenn die Anforderung keine nachfolgenden Header unterstützt.

Weitere Informationen finden Sie unter [Put Request Trailers in a separate Collection (dotnet/aspnetcore-#10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Allowsynchronousio deaktiviert

`AllowSynchronousIO` aktiviert oder deaktiviert synchrone e/a-APIs, wie `HttpRequest.Body.Read` z `HttpResponse.Body.Write` . b `Stream.Flush` ., und. Diese APIs sind eine Quelle der Thread Hungersnot, die zu app-Abstürzen führt. In 3.0 ist `AllowSynchronousIO` standardmäßig deaktiviert. Weitere Informationen finden Sie [im Abschnitt "Synchrone e/a" im Kestrel-Artikel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io).

Wenn eine synchrone e/a erforderlich ist, kann Sie aktiviert werden, indem die- `AllowSynchronousIO` Option auf dem verwendeten Server konfiguriert wird ( `ConfigureKestrel` z. b. bei Verwendung von Kestrel). Beachten Sie, dass Server (Kestrel, httpsys, Testserver usw.) über eine eigene `AllowSynchronousIO` Option verfügen, die sich nicht auf andere Server auswirkt. Synchrone e/a-Vorgänge können für alle Server auf Anforderungs Basis aktiviert werden. verwenden Sie dazu die folgende `IHttpBodyControlFeature.AllowSynchronousIO` Option:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme mit <xref:System.IO.TextWriter> Implementierungen oder anderen Streams [haben,](/dotnet/standard/garbage-collection/implementing-dispose)die synchrone APIs in verwerfen aufzurufen, müssen Sie stattdessen die neue <xref:System.IO.Stream.DisposeAsync*> API abrufen.

Weitere Informationen finden Sie unter [[Ankündigung] allowsynchronousio deaktiviert auf allen Servern (dotnet/aspnetcore-#7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Ausgabe formatiererpufferung

[Newtonsoft.Jsauf](https://www.newtonsoft.com/json) <xref:System.Xml.Serialization.XmlSerializer> -,-und- <xref:System.Runtime.Serialization.DataContractSerializer> basierten Ausgabe Formatierern unterstützen nur die synchrone Serialisierung. Damit diese Formatierer mit den [allowsynchronousio](https://github.com/dotnet/aspnetcore/issues/7644) -Einschränkungen des Servers arbeiten können, puffert MVC die Ausgabe dieser Formatierer, bevor Sie auf den Datenträger geschrieben wird. Aufgrund der Pufferung schließt MVC den Content-Length-Header ein, wenn er mithilfe dieser Formatierer antwortet.

<xref:System.Text.Json> unterstützt die asynchrone Serialisierung `System.Text.Json` . Folglich wird der basierte Formatierer nicht gepuffert. Verwenden Sie diesen Formatierer, um die Leistung zu verbessern.

Zum Deaktivieren der Pufferung können Anwendungen <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> beim Starten konfigurieren:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Beachten Sie, dass dies dazu führen kann, dass die Anwendung eine Lauf Zeit Ausnahme auslöst, wenn `AllowSynchronousIO` nicht auch konfiguriert ist.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Die Assembly "Microsoft. aspnetcore. Server. Kestrel. https" wurde entfernt.

In ASP.net Core 2,1 wurde der Inhalt *Microsoft.AspNetCore.Server.Kestrel.Https.dll* in *Microsoft.AspNetCore.Server.Kestrel.Core.dll* verschoben. Dabei handelt es sich um ein nicht Erbrechtes Update mit `TypeForwardedTo` Attributen. Bei 3,0 wurden die leeren *Microsoft.AspNetCore.Server.Kestrel.Https.dll* Assembly und das nuget-Paket entfernt.

Bibliotheken, die auf [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.net Core Abhängigkeiten auf 2,1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.net Core 2,1 oder höher abzielen, sollten alle direkten Verweise auf das Paket [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Unterstützung für Newtonsoft.Json (JSON.net)

Im Rahmen der Arbeit zur [Verbesserung der ASP.net Core freigegebenen Frameworks](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde [Newtonsoft.Json (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem ASP.net Core Shared Framework entfernt.

Der Standard-JSON-Serialisierer für ASP.net Core ist jetzt <xref:System.Text.Json> , der in .net Core 3,0 neu ist. Verwenden Sie nach Möglichkeit die Verwendung von `System.Text.Json` . Dies ist eine hohe Leistung und erfordert keine zusätzliche Bibliotheks Abhängigkeit. Da jedoch `System.Text.Json` neu ist, fehlen möglicherweise derzeit die Features, die Ihre APP benötigt. Weitere Informationen finden Sie unter [Migrieren von Newtonsoft.Json zu System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>Verwenden von Newtonsoft.Json in einem ASP.net Core 3,0- SignalR Projekt

* Installieren Sie [Microsoft. aspnetcore. SignalR Das nuget-Paket "Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) ".

* Verketten Sie auf dem Client einen `AddNewtonsoftJsonProtocol` Methoden Aufrufder- `HubConnectionBuilder` Instanz:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Verketten Sie auf dem-Server einen `AddNewtonsoftJsonProtocol` Methodenaufrufe des- `AddSignalR` Methoden Aufrufes in `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Verwenden von Newtonsoft.Json in einem ASP.net Core 3,0-MVC-Projekt

* Installieren Sie das [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Paket.

* Aktualisieren `Startup.ConfigureServices` , um aufzurufen `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` Einstellungen können im-Befehl festgelegt werden `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

  **Hinweis:** Wenn die `AddNewtonsoftJson` Methode nicht verfügbar ist, stellen Sie sicher, dass Sie das Paket installiert haben [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Ein häufiger Fehler besteht darin, die [Newtonsoft.Jsfür](https://www.nuget.org/packages/Newtonsoft.Json/) das Paket anstelle des [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Pakets zu installieren.

Weitere Informationen finden [Sie unter Hinzufügen Newtonsoft.Json-based JSON-Formatunterstützung](xref:web-api/advanced/formatting#add-newtonsoftjson-based-json-format-support).

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

In ASP.net Core 3,0 werden neue Optionen zum Registrieren von MVC-Szenarien in hinzugefügt `Startup.ConfigureServices` .

Drei neue Erweiterungs Methoden der obersten Ebene, die sich auf MVC-Szenarios für beziehen, `IServiceCollection` sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `AddMvc` . Verhält sich jedoch `AddMvc` weiterhin wie in früheren Versionen.

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird die Unterstützung für Razor Seiten und die minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen von `AddMvc` in ASP.net Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing Startcode

Wenn eine APP `UseMvc` oder aufruft `UseSignalR` , migrieren Sie die APP nach Möglichkeit zum [Endpunkt Routing](xref:fundamentals/routing) . Um die Kompatibilität mit dem Endpunkt Routing mit früheren Versionen von MVC zu verbessern, haben wir einige der Änderungen in der URL-Generierung wieder hergestellt, die in ASP.net Core 2,2 eingeführt wurden. Wenn bei der Verwendung des Endpunkt Routings in 2,2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.net Core 3,0 mit folgenden Ausnahmen:

* Wenn die APP implementiert `IRouter` oder von der Anwendung erbt `Route` , verwenden Sie [dynamicroutevaluestransex](https://github.com/dotnet/AspNetCore.Docs/issues/12997) als Ersatz.
* Wenn die APP direkt `RouteData.Routers` in MVC zugreift, um URLs zu analysieren, können Sie dies durch die Verwendung von [linkparser. parspathbyendpointname](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)ersetzen. 
  * Hiermit wird die Route mit einem Routennamen definiert.
  * Verwenden Sie, `LinkParser.ParsePathByEndpointName` und übergeben Sie den gewünschten Routennamen.

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum Erstellen von Routen Mustern wie `IRouter` . Das Endpunkt Routing unterstützt `IRouteConstraint` . Das Endpunkt Routing unterstützt `[Route]` , `[HttpGet]` und die anderen MVC-Routing Attribute.

Bei den meisten Anwendungen `Startup` müssen nur Änderungen vorgenommen werden.

### <a name="migrate-startupconfigure"></a>Migrieren Startup.Configure

Allgemeine Hinweise:

* Fügen Sie `UseRouting`hinzu.
* Wenn die APP aufruft `UseStaticFiles` , platzieren Sie es `UseStaticFiles` **vor** `UseRouting` .
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures wie `AuthorizePage` oder verwendet `[Authorize]` , platzieren Sie den-Befehl unter `UseAuthentication` und `UseAuthorization` : **nach** und `UseRouting` `UseCors` , aber vor `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Ersetzen Sie `UseMvc` oder `UseSignalR` durch `UseEndpoints` .
* Wenn die APP [cors](xref:security/cors) -Szenarien (z. b.) verwendet, `[EnableCors]` platzieren Sie den-Anrufe `UseCors` vor allen anderen Middleware, die cors verwenden (z `UseCors` . b. platzieren vor `UseAuthentication` , `UseAuthorization` und `UseEndpoints` ).
* Ersetzen `IHostingEnvironment` Sie durch, `IWebHostEnvironment` und fügen Sie eine- `using` Anweisung für den <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace hinzu.
* Ersetzen Sie dies `IApplicationLifetime` durch <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (- <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).
* Ersetzen Sie dies `EnvironmentName` durch <xref:Microsoft.Extensions.Hosting.Environments> (- <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).

Der folgende Code ist ein Beispiel für `Startup.Configure` eine typische ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des vorherigen `Startup.Configure` Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten apps müssen Aufrufe von `UseAuthentication` , `UseAuthorization` und `UseCors` zwischen den Aufrufen von und auftreten `UseRouting` , `UseEndpoints` um wirksam zu werden.

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen verwenden das Endpunktrouting mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Für Endpunkte für Integritätsprüfungen gilt Folgendes:

* Sie geben mindestens einen zugelassenen Host oder Port an.
* Sie erfordern Autorisierung.
* Sie erfordern CORS.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, cors zu konfigurieren. Die Middleware wurde zur Verwendung in einigen Anwendungsfällen bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen **ohne** die Middleware vorgesehen. Bei ASP.net Core 3,0 wird empfohlen, dass alle apps, die cors benötigen, die cors-Middleware zusammen mit dem Endpunkt Routing verwenden. `UseCors` kann mit einer Standard Richtlinie angegeben werden, und `[EnableCors]` die-und- `[DisableCors]` Attribute können verwendet werden, um die Standard Richtlinie nach Bedarf zu überschreiben.

Siehe folgendes Beispiel:

* Cors ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die- `MyController` Klasse deaktiviert cors mit dem- `[DisableCors]` Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

In früheren Versionen von ASP.net Core wurde Unterstützung der Autorisierung über das-Attribut bereitgestellt `[Authorize]` . Die Autorisierungs Middleware war nicht verfügbar. In ASP.net Core 3,0 ist die Autorisierungs Middleware erforderlich. Es wird empfohlen, die ASP.net Core Autorisierungs Middleware ( `UseAuthorization` ) direkt nach zu platzieren `UseAuthentication` . Die Middleware für die Autorisierung kann auch mit einer Standard Richtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.net Core 3,0 oder höher `UseAuthorization` wird in aufgerufen `Startup.Configure` , und für Folgendes ist ein angemeldeter `HomeController` Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn Sie das Endpunkt Routing verwenden, wird empfohlen, `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` die Autorisierungs Middleware zu konfigurieren und stattdessen darauf zu vertrauen.  Wenn die APP `AuthorizeFilter` als globaler Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass er eine Richtlinie im-Befehl bereitstellt `AddAuthorization` .

Das `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden die MVC-Endpunkte als markiert, `RequireAuthorization` sodass alle Anforderungen auf der Grundlage von autorisiert werden müssen `DefaultPolicy` . Der ermöglicht jedoch den `HomeController` Zugriff, ohne dass der Benutzer sich bei der App anmeldet. Dies liegt an folgendem `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisierung für bestimmte Endpunkte

Die Autorisierung kann auch für bestimmte Klassen von Endpunkten konfiguriert werden. Der folgende Code ist ein Beispiel für die Umstellung einer MVC-APP, die eine globale `AuthorizeFilter` in eine APP mit einer bestimmten Richtlinie konfiguriert, die eine Autorisierung erfordert:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Richtlinien können auch angepasst werden. Der `DefaultPolicy` ist so konfiguriert, dass eine Authentifizierung erforderlich ist:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativ können alle Endpunkte so konfiguriert werden, dass Sie ohne `[Authorize]` oder `RequireAuthorization` durch Konfigurieren von eine Autorisierung erfordern `FallbackPolicy` . Der `FallbackPolicy` unterscheidet sich vom `DefaultPolicy` . `DefaultPolicy`Wird von oder ausgelöst `[Authorize]` `RequireAuthorization` , während das `FallbackPolicy` ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `FallbackPolicy` ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorherigen `DefaultPolicy` Beispiel, verwendet jedoch `FallbackPolicy` , um immer eine Authentifizierung für alle Endpunkte anzufordern, außer wenn `[AllowAnonymous]` angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel wird die `UseAuthorization` Autorisierung mit der verarbeitet `DefaultPolicy` , aber der Integritäts `/healthz` Prüfung-Endpunkt erfordert einen `admin` Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. Die Middleware für Endpunkte löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

#### <a name="custom-authorization-handlers"></a>Benutzerdefinierte Autorisierungs Handler

Wenn die APP benutzerdefinierte [Autorisierungs Handler](xref:security/authorization/policies#authorization-handlers)verwendet, übergibt das Endpunkt Routing einen anderen Ressourcentyp an Handler als MVC. Handler, die erwarten, dass die Kontext Ressource des Autorisierungs Handler vom Typ ist <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (der [von MVC-Filtern bereitgestellte](xref:security/authorization/policies#access-mvc-request-context-in-handlers)Ressourcentyp), muss aktualisiert werden, damit die Ressourcen des Typs <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (der Ressourcentyp, der den Autorisierungs Handlern durch Endpunkt Routing zugewiesen ist) verarbeitet werden

Da MVC weiterhin `AuthorizationFilterContext` Ressourcen verwendet, ist es möglicherweise erforderlich, beide Arten von Ressourcen zu verarbeiten, wenn die APP MVC-Autorisierungs Filter zusammen mit der Endpunkt Weiterleitungs Autorisierung verwendet.

### SignalR

Die Zuordnung von SignalR Hubs erfolgt nun in `UseEndpoints` .

Ordnen Sie jeden Hub mit zu `MapHub` . Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für den `ChatHub` SignalR Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Gehen Sie beispielsweise in `Startup.ConfigureServices` folgendermaßen vor:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2,2 konnten Sie die festlegen, die `TransportMaxBufferSize` die maximale Nachrichtengröße effektiv steuern würde. In ASP.net Core 3,0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückdruck festgestellt wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung von Controllern erfolgt nun in `UseEndpoints` .

Fügen Sie hinzu, `MapControllers` Wenn die APP Attribut Routing verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.net Core 3,0 oder höher bietet, ist das Hinzufügen von Attribut Weiterleitungs Controllern ein Opt-in.

Ersetzen Sie Folgendes:

* `MapRoute` mit `MapControllerRoute`
* `MapAreaRoute` mit `MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche Routen wie `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` werden in der Reihenfolge angewendet, in der Sie hinzugefügt werden. Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Siehe folgendes Beispiel:

* `MapControllers` Fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute` Fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute` Fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Asynchrones Suffix aus Controller-Aktions Namen entfernen

In ASP.net Core 3,0 entfernt ASP.net Core MVC das `Async` Suffix aus den Controller Aktions Namen. Das Routing und die Verknüpfungs Generierung sind von dieser neuen Standardeinstellung betroffen. Zum Beispiel:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Vor ASP.net Core 3,0:

* Auf die vorherige Aktion kann auf der Route " *Products/listasync* " zugegriffen werden.
* Die Link Generierung erforderte das Angeben des Suffixes `Async` . Zum Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.net Core 3,0:

* Auf die vorangehende Aktion kann auf der Route " *Products/List* " zugegriffen werden.
* Bei der Link Generierung muss das Suffix nicht angegeben werden `Async` . Zum Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Diese Änderung wirkt sich nicht auf die mit dem-Attribut angegebenen Namen aus [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Das Standardverhalten kann mit dem folgenden Code in deaktiviert werden `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Änderungen an der Link Generierung

Wie in der Dokumentation zu den [unterschieden aus früheren Versionen des Routings](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)erläutert, gibt es einige Unterschiede bei der Link Generierung ( `Url.Link` z. b. mit und ähnlichen APIs). Dazu gehören:

* Wenn Sie das Endpunkt Routing verwenden, wird die Groß-/Kleinschreibung von Routen Parametern in generierten URIs standardmäßig nicht zwangsläufig beibehalten. Dieses Verhalten kann mit der- `IOutboundParameterTransformer` Schnittstelle gesteuert werden.
* Wenn Sie einen URI für eine ungültige Route generieren (ein Controller, eine Aktion oder eine Seite, die nicht vorhanden ist), wird unter Endpunkt Routing eine leere Zeichenfolge erstellt, anstatt einen ungültigen URI zu erzeugen.
* Ambient-Werte (Routen Parameter aus dem aktuellen Kontext) werden bei der Link Generierung mit dem Endpunkt Routing nicht automatisch verwendet. Zuvor wurden bei der Erstellung eines Links zu einer anderen Aktion (oder Seite) nicht angegebene Routen Werte von den *aktuellen* Routen Werten abgeleitet. Bei Verwendung des Endpunkt Routings müssen alle Routen Parameter während der Link Generierung explizit angegeben werden.

### <a name="no-locrazor-pages"></a>Razor Pages

Die Zuordnung von Razor Seiten erfolgt nun in `UseEndpoints` .

Fügen Sie hinzu, `MapRazorPages` Wenn die APP Razor Seiten verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks umfasst, ist das Hinzufügen von Razor Seiten jetzt deaktiviert.

In der folgenden `Startup.Configure` Methode `MapRazorPages` Fügt Unterstützung für Razor Seiten hinzu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von MVC über `UseMvc` oder `UseMvcWithDefaultRoute` in ASP.net Core 3,0 erfordert ein explizites Opt-in in `Startup.ConfigureServices` . Dies ist erforderlich, da MVC wissen muss, ob es während der Initialisierung auf die Autorisierung und die cors-Middleware zurückgreifen kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die APP versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die APP Legacy `IRouter` Unterstützung erfordert, deaktivieren `EnableEndpointRouting` Sie die Verwendung der folgenden Ansätze in `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen Sie hinzu `MapHealthChecks` , um Integritätsprüfungen mit Endpunkt Routing zu verwenden. Die- `MapHealthChecks` Methode akzeptiert Argumente ähnlich wie `UseHealthChecks` . Der Vorteil der Verwendung von `MapHealthChecks` over `UseHealthChecks` ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel `MapHealthChecks` wird für einen Integritäts Prüf Punkt aufgerufen `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

In den ASP.net Core 3,0-Vorlagen wird [generischer Host](xref:fundamentals/host/generic-host)verwendet. In früheren Versionen wurde [Webhost](xref:fundamentals/host/web-host)verwendet. Der folgende Code zeigt die von der ASP.net Core 3,0-Vorlage generierte `Program` Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die von der Vorlage generierte ASP.net Core 2,2- `Program` Klasse:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> verbleibt in 3,0 und ist der Typ von, der `webBuilder` im vorangehenden Codebeispiel angezeigt wird. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> wird in einer zukünftigen Version als veraltet markiert und durch ersetzt `HostBuilder` .

Die signifikanteste Änderung von in `WebHostBuilder` `HostBuilder` ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn `HostBuilder` Sie verwenden, können Sie nur den folgenden in `Startup` den-Konstruktor einfügen:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

Weitere Informationen finden Sie unter [vermeiden der Start Dienst Injektion in ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die Methoden ASP.net Core 2,2 und niedriger `AddAuthorization` in *Microsoft.AspNetCore.Authorization.dll* :

* Wurden umbenannt `AddAuthorizationCore` .
* Wurden in *Microsoft.AspNetCore.Authorization.Policy.dll* verschoben.

Apps, die sowohl *Microsoft.AspNetCore.Authorization.dll* als auch *Microsoft.AspNetCore.Authorization.Policy.dll* verwenden, sind nicht betroffen.

Apps, die *Microsoft.AspNetCore.Authorization.Policy.dll* nicht verwenden, sollten eine der folgenden Aktionen ausführen:

* Fügen Sie einen Verweis auf *Microsoft.AspNetCore.Authorization.Policy.dll* hinzu. Diese Vorgehensweise funktioniert für die meisten apps und ist alles, was erforderlich ist.
* Wechseln zu mithilfe von `AddAuthorizationCore`

Weitere Informationen finden Sie unter [Breaking Change in (Breaking Change in `AddAuthorization(o =>` ) der Überlastung in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>Benutzeroberfläche von Identity

Identity Aktualisierungen der Benutzeroberfläche für ASP.net Core 3,0:

* Fügen Sie einen Paket Verweis auf [Microsoft. aspnetcore hinzu. Identity Benutzeroberfläche](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Apps, die keine Razor Seiten verwenden, müssen aufruft `MapRazorPages` . Siehe [ Razor Seiten](#razor-pages) in diesem Dokument.
* Bootstrap 4 ist das Standard Framework für die Benutzeroberfläche. Legen `IdentityUIFrameworkVersion` Sie eine Projekt Eigenschaft fest, um die Standardeinstellung zu ändern. Weitere Informationen finden Sie in [dieser GitHub-Ankündigung](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Der SignalR JavaScript-Client wurde von `@aspnet/signalr` in geändert `@microsoft/signalr` . Um auf diese Änderung zu reagieren, ändern Sie die Verweise in *package.jsfür* Dateien, `require` Anweisungen und ECMAScript- `import` Anweisungen.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json ist das Standardprotokoll.

`System.Text.Json` ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

In `Startup.ConfigureServices` wird aufgerufen, `AddJsonProtocol` um Serialisierungsoptionen festzulegen.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Zum Newtonsoft.Jswechseln

Wenn Sie [Features von Newtonsoft.Json verwenden, die in System.Text.Jsnicht unterstützt](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)werden, können Sie zurück zu wechseln `Newtonsoft.Json` . Weitere Informationen finden Sie weiter oben in diesem Artikel unter [Verwenden von Newtonsoft.Jsin einem ASP.net Core 3,0- SignalR Projekt](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) .

## <a name="redis-distributed-caches"></a>Verteilte redis-Caches

Das [Microsoft. Extensions. Caching. redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) -Paket ist für 3,0 ASP.net Core-Apps oder höher nicht verfügbar. Ersetzen Sie den Paket Verweis durch [Microsoft. Extensions. Caching. stackexchangeredis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Weitere Informationen finden Sie unter <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

Vor ASP.net Core 3,0 war die Lauf Zeit Kompilierung von Sichten eine implizite Funktion des Frameworks. Die Lauf Zeit Kompilierung ergänzt die Kompilierung der Erstellung von Sichten. Dadurch kann das Framework Razor Sichten und Seiten ( *cshtml* -Dateien) kompilieren, wenn die Dateien geändert werden, ohne dass die gesamte APP neu erstellt werden muss. Diese Funktion unterstützt das Szenario der schnellen Bearbeitung in der IDE und das Aktualisieren des Browsers, um die Änderungen anzuzeigen.

In ASP.net Core 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Die Kompilierzeit Kompilierung ist der einzige Mechanismus zum Anzeigen der Kompilierung, der standardmäßig aktiviert ist. Die Laufzeit basiert auf Visual Studio oder [dotnet-Watch](xref:tutorials/dotnet-watch) in Visual Studio Code, um das Projekt neu zu erstellen, wenn Änderungen an *cshtml* -Dateien erkannt werden. In Visual Studio werden Änderungen an *den CS* - *, cshtml* -oder *Razor* -Dateien im Projekt, das ausgeführt wird ( <kbd>STRG + F5</kbd>), aber nicht debuggt ( <kbd>F5</kbd>), die Neukompilierung des Projekts auslöst.

So aktivieren Sie die Lauf Zeit Kompilierung in Ihrem ASP.net Core 3,0-Projekt:

1. Installieren Sie [Microsoft. aspnetcore. MVC. Razor . Runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) -nuget-Paket.
1. Update `Startup.ConfigureServices` zum aufzurufen `AddRazorRuntimeCompilation` :

    Verwenden Sie für ASP.net Core MVC den folgenden Code:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Verwenden Sie für ASP.net Core Razor Seiten den folgenden Code:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Das Beispiel unter https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation zeigt ein Beispiel für die bedingte Aktivierung der Lauf Zeit Kompilierung in Entwicklungsumgebungen.

Weitere Informationen zur Razor Kompilierung von Dateien finden Sie unter <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken mithilfe der Zielplattform

Bibliotheken müssen häufig mehrere Versionen von ASP.net Core unterstützen. Die meisten Bibliotheken, die für frühere Versionen von ASP.net Core kompiliert wurden, sollten ohne Probleme weiterhin funktionieren. Die folgenden Bedingungen erfordern eine Kreuz Kompilierung der APP:

* Die Bibliothek basiert auf einer Funktion, die über eine binäre [Breaking Change](#breaking-api-changes)verfügt.
* Die Bibliothek möchte die neuen Features in ASP.net Core 3,0 nutzen. 

Zum Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden `#ifdefs` Sie, um ASP.net Core 3,0-spezifische APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Weitere Informationen zum Verwenden von ASP.net Core-APIs in einer Klassenbibliothek finden Sie unter <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Verschiedene Änderungen

Das Validierungssystem in .NET Core 3.0 und höher behandelt Non-Nullable-Parameter oder gebundene Eigenschaften so, als würden sie ein `[Required]`-Attribut aufweisen. Weitere Informationen finden Sie unter [[Required]-Attribut](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Veröffentlichen

Löschen Sie die Ordner " *bin* " und " *obj* " im Projektverzeichnis.

## <a name="testserver"></a>TestServer

Erstellen Sie für apps, die <xref:Microsoft.AspNetCore.TestHost.TestServer> direkt mit dem [generischen Host](xref:fundamentals/host/web-host)verwendet werden, `TestServer` auf einem <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> in <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Wichtige API-Änderungen

Wichtige Änderungen überprüfen:

* [Umfassende Liste der wichtigen Änderungen in der Version ASP.net Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Unterbrechen von API-Änderungen in Antifälschung, cors, Diagnose, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält Breaking Changes für Kompatibilitätsoptionen.
* Eine Zusammenfassung 2,2-zu-3,0-Änderungen in .net Core, ASP.net Core und Entity Framework Core finden Sie unter [Breaking Changes for Migration from Version 2,2 to 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Endpunkt Routing mit Catch-All-Parameter

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.Net Core 3,0 auf Azure App Service

Das Rollout von .net Core auf Azure App Service ist abgeschlossen. .Net Core 3,0 ist in allen Azure App Service Rechenzentren verfügbar.